diff --git a/lua/fzf-lua/defaults.lua b/lua/fzf-lua/defaults.lua
index a98088b..b658d31 100644
--- a/lua/fzf-lua/defaults.lua
+++ b/lua/fzf-lua/defaults.lua
@@ -425,6 +425,7 @@ M.defaults.buffers = {
   ignore_current_buffer = false,
   no_action_set_cursor  = true,
   cwd_only              = false,
+  ls_cmd                = nil,
   cwd                   = nil,
   fzf_opts              = { ["--tiebreak"] = "index", },
   _actions              = function() return M.globals.actions.buffers end,
diff --git a/lua/fzf-lua/providers/buffers.lua b/lua/fzf-lua/providers/buffers.lua
index daa9d25..65b129c 100644
--- a/lua/fzf-lua/providers/buffers.lua
+++ b/lua/fzf-lua/providers/buffers.lua
@@ -59,8 +59,10 @@ end
 local populate_buffer_entries = function(opts, bufnrs, tabh)
   local buffers = {}
   for _, bufnr in ipairs(bufnrs) do
-    local flag = (bufnr == core.CTX().bufnr and "%")
-        or (bufnr == core.CTX().alt_bufnr and "#") or " "
+    local flag = (opts.buf_flags and opts.buf_flags[bufnr])
+        or (bufnr == core.CTX().bufnr and "%")
+        or (bufnr == core.CTX().alt_bufnr and "#")
+        or " "
 
     local element = {
       bufnr = bufnr,
@@ -94,9 +96,9 @@ local populate_buffer_entries = function(opts, bufnrs, tabh)
     -- DON'T FORCE ME TO UPDATE THIS HACK NEOVIM LOL
     local future = os.time({ year = 2100, month = 1, day = 1, hour = 0, minute = 00 })
     local get_unixtime = function(buf)
-      if buf.flag == "%" then
+      if buf.flag:match("%%") then
         return future
-      elseif buf.flag == "#" then
+      elseif buf.flag:match("#") then
         return future - 1
       else
         return buf.info.lastused
@@ -111,11 +113,10 @@ end
 
 
 local function gen_buffer_entry(opts, buf, max_bufnr, cwd)
-  -- local hidden = buf.info.hidden == 1 and 'h' or 'a'
-  local hidden = ""
-  local readonly = buf.readonly and "=" or " "
-  local changed = buf.info.changed == 1 and "+" or " "
-  local flags = hidden .. readonly .. changed
+  -- if opts.buf_flags is set, buf.flag already includes all the flag
+  -- we need, so don't add extra flags here
+  local flags = opts.buf_flags and ""
+      or ((buf.readonly and "=" or " ") .. (buf.info.changed == 1 and "+" or " "))
   local leftbr = "["
   local rightbr = "]"
   local bufname = #buf.info.name > 0 and path.relative(buf.info.name, cwd or vim.loop.cwd())
@@ -129,12 +130,12 @@ local function gen_buffer_entry(opts, buf, max_bufnr, cwd)
   end
   -- add line number
   bufname = ("%s:%s"):format(bufname, buf.info.lnum > 0 and buf.info.lnum or "")
-  if buf.flag == "%" then
+  if buf.flag:match("%%") then
     flags = utils.ansi_codes[opts.hls.buf_flag_cur](buf.flag) .. flags
-  elseif buf.flag == "#" then
+  elseif buf.flag:match("#") then
     flags = utils.ansi_codes[opts.hls.buf_flag_alt](buf.flag) .. flags
   else
-    flags = utils.nbsp .. flags
+    flags = buf.flag .. flags
   end
   local bufnrstr = string.format("%s%s%s", leftbr,
     utils.ansi_codes[opts.hls.buf_nr](tostring(buf.bufnr)), rightbr)
@@ -174,7 +175,26 @@ M.buffers = function(opts)
 
   opts.__fn_reload = opts.__fn_reload or function(_)
     return function(cb)
-      local filtered, _, max_bufnr = filter_buffers(opts, core.CTX().buflist)
+      local buflist = {}
+      if not opts.ls_cmd then
+        buflist = core.CTX().buflist
+      else -- use `:ls` output as buffer list
+        -- use buffer flags from `:ls` output instead of generating
+        -- new buffer flags in `populate_buffer_entries()`
+        opts.buf_flags = {}
+        local alt_win = vim.fn.win_getid(vim.fn.winnr("#"))
+        -- call ls command in alternate window to get correct buffer flags
+        -- for current and alternate buffers ('%' and '#')
+        local ls_output = vim.split(vim.api.nvim_win_call(alt_win, function()
+          return vim.fn.execute(opts.ls_cmd)
+        end), "\n", { trimempty = true })
+        for _, line in ipairs(ls_output) do
+          local bufnr = tonumber(line:match("^%s*(%d+)"))
+          table.insert(buflist, bufnr)
+          opts.buf_flags[bufnr] = line:match("^%s*%d+([^\"]*)")
+        end
+      end
+      local filtered, _, max_bufnr = filter_buffers(opts, buflist)
 
       if next(filtered) then
         local buffers = populate_buffer_entries(opts, filtered)
diff --git a/lua/fzf-lua/providers/nvim.lua b/lua/fzf-lua/providers/nvim.lua
index 67ab103..9996dcc 100644
--- a/lua/fzf-lua/providers/nvim.lua
+++ b/lua/fzf-lua/providers/nvim.lua
@@ -83,18 +83,11 @@ local history = function(opts, str)
   core.fzf_exec(entries, opts)
 end
 
-local arg_header = function(sel_key, edit_key, text)
-  sel_key = utils.ansi_codes.yellow(sel_key)
-  edit_key = utils.ansi_codes.yellow(edit_key)
-  return vim.fn.shellescape((":: %s to %s, %s to edit")
-    :format(sel_key, text, edit_key))
-end
-
 M.command_history = function(opts)
   opts = config.normalize_opts(opts, "command_history")
   if not opts then return end
-  if opts.fzf_opts["--header"] == nil then
-    opts.fzf_opts["--header"] = arg_header("<CR>", "<Ctrl-e>", "execute")
+  if opts.headers then
+    opts = core.set_header(opts, opts.headers)
   end
   history(opts, "cmd")
 end
@@ -102,8 +95,8 @@ end
 M.search_history = function(opts)
   opts = config.normalize_opts(opts, "search_history")
   if not opts then return end
-  if opts.fzf_opts["--header"] == nil then
-    opts.fzf_opts["--header"] = arg_header("<CR>", "<Ctrl-e>", "search")
+  if opts.headers then
+    opts = core.set_header(opts, opts.headers)
   end
   history(opts, "search")
 end
diff --git a/lua/fzf-lua/win.lua b/lua/fzf-lua/win.lua
index 43b0094..9ca2300 100644
--- a/lua/fzf-lua/win.lua
+++ b/lua/fzf-lua/win.lua
@@ -1391,10 +1391,10 @@ function FzfWin.toggle_help()
     style = "minimal",
     width = vim.o.columns,
     height = height,
-    row = vim.o.lines - height - vim.o.cmdheight - 2,
+    row = 0,
     col = 1,
     -- top border only
-    border = { " ", "â”€", " ", " ", " ", " ", " ", " " },
+    border = "single",
     -- topmost popup
     zindex = 999,
   }
